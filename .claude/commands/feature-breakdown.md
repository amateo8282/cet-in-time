# Feature Breakdown 커맨드

해결해야 할 문제나 기능을 입력받아 작은 태스크로 분해합니다.

## 입력

**이슈**: $ARGUMENTS

## 수행 작업

### 1. 이슈 분석

입력된 이슈 "$ARGUMENTS"를 분석하여 다음을 파악하세요:

- **문제 정의**: 해결해야 할 핵심 문제가 무엇인가?
- **범위**: 영향받는 기능, 모듈, 사용자는?
- **제약 조건**: 기술적/비즈니스적 제약이 있는가?
- **성공 기준**: 문제가 해결되었음을 어떻게 확인할 수 있는가?

### 2. 문제 분해 (MECE 원칙)

이슈를 다음 원칙에 따라 세분화하세요:

- **상호 배타적(Mutually Exclusive)**: 각 태스크가 중복되지 않음
- **전체 포괄적(Collectively Exhaustive)**: 모든 태스크를 합치면 전체 문제 해결

**분해 기준**:
1. 기능 단위로 분해
2. 각 기능을 구현 단계로 분해
3. 2-4시간 내 완료 가능한 크기까지 세분화

### 3. 기존 플랜 참조 (선택)

`docs/plans/` 디렉토리에 관련 문서가 있다면 참조하세요:
- `Plan.md`: 전체 계획
- `PRD.md`: 제품 요구사항
- `TRD.md`: 기술 요구사항
- `TASK.md`: 기존 태스크 목록

### 4. 클린 아키텍처 계층별 분류

분해된 태스크를 다음 계층으로 분류하세요:

1. **Domain Layer (도메인 계층)**
   - 필요한 엔티티, 값 객체
   - 도메인 서비스 및 비즈니스 규칙

2. **Application Layer (애플리케이션 계층)**
   - 유스케이스 정의
   - 필요한 인터페이스 (Repository, Service)

3. **Infrastructure Layer (인프라 계층)**
   - 외부 API, 데이터베이스 연동
   - Repository 구현

4. **Presentation Layer (프레젠테이션 계층)**
   - UI 컴포넌트
   - 상태 관리, 사용자 상호작용

### 5. TDD 연계 태스크 도출

각 계층에 대해 TDD 사이클(Red-Green-Refactor)을 적용한 태스크를 생성하세요.

### 6. 출력 형식

#### 요약

```markdown
## 이슈 요약

**원본 이슈**: $ARGUMENTS
**분해된 태스크 수**: [N]개
**예상 의존성 그래프**:
태스크 1 → 태스크 2 → 태스크 4
         ↘ 태스크 3 ↗
```

#### 태스크 상세

각 태스크는 다음 형식으로 출력하세요:

```markdown
## 태스크 [번호]: [태스크 제목]

**계층**: [Domain/Application/Infrastructure/Presentation]

**설명**: [태스크에 대한 상세 설명]

**TDD 단계**:
1. Red: [실패하는 테스트 작성 내용]
2. Green: [테스트 통과를 위한 최소 구현]
3. Refactor: [리팩토링 포인트]

**완료 조건**:
- [ ] [구체적인 완료 조건 1]
- [ ] [구체적인 완료 조건 2]

**의존성**: [선행 태스크 번호 또는 "없음"]

**커밋 메시지**: `[한글로 작성된 커밋 메시지]`
```

### 7. 우선순위 및 순서

태스크는 다음 순서로 정렬하세요:
1. Domain 계층 (의존성 없음)
2. Application 계층 (Domain에 의존)
3. Infrastructure 계층 (Application 인터페이스 구현)
4. Presentation 계층 (모든 계층 통합)

---

## 실행

위 지침에 따라 이슈 "$ARGUMENTS"를 분석하고 실행 가능한 태스크로 분해하세요.
기존 `docs/plans/` 문서가 있다면 참조하고, 없다면 새로운 분석을 수행하세요.
